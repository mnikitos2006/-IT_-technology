### Сравнение значений

Есть два основных типа сравнения значений, которые могут понадобиться вам в JS программах: *равенство* и *неравенство*.
Результатом любого сравнения является только значение типа `boolean` (`true` или `false`), независимо от сравниваемых
типов значений.

#### Приведение типов (coercion)

Приведение в JavaScript существует в двух формах: *явное* и *неявное*. Явное приведение — это когда можно явным образом
увидеть в коде конвертации из одного типа в другой, в свою очередь, неявное приведение — это когда конвертация
происходит в результате менее очевидных побочных эффектов других операций.

Возможно, вы слышали мнения по типу "приведение типов - зло", опирающиеся на факт того, что безусловно существуют места,
где приведение может привести к удивительным результатам. Конечно, ничто так не расстраивает разработчиков как моменты,
когда язык преподносит им сюрпризы.

Приведение — не зло и не должно преподносить сюрпризов. На самом деле, большинство сценариев, которые вы можете
построить, используя приведение типов, вполне адекватны и понятны, они даже могут использоваться с целью *увеличить*
читаемость вашего кода.

Вот пример *явного* приведения:

```js
var a = "42";
var b = Number(a);
a;				// "42"
b;				// 42 — число!
```

А вот пример *неявного* приведения:

```js
var a = "42";
var b = a * 1;	// здесь "42" неявно приводится к 42
a;				// "42"
b;				// 42 — число!
```

#### Как бы истинный и ложный

Особый список "как бы ложных" значений в JavaScript таков:

* `""` (пустая строка)
* `0`, `-0`, `NaN` (некорректное `число`)
* `null`, `undefined`
* `false`

Любое значение, не входящее в этот список — "как бы истинно." Вот несколько примеров:

* `"hello"`
* `42`
* `true`
* `[ ]`, `[ 1, "2", 3 ]` (массивы)
* `{ }`, `{ a: 42 }` (объекты)
* `function foo() { .. }` (функции)

Важно помнить, что не-`boolean` значение следует такому приведению "истинный"/"ложный", только если оно действительно
приводится к `boolean`. Это не единственная трудность, которая может смутить вас в ситуации, когда кажется, что значение
приводится к `boolean`, хотя на самом деле это не так.

#### Равенство

Есть четыре операции равенства: `==`, `===`, `!=` и `!==`. Формы с `!` — конечно же, симметричные версии "не равно"
своих противоположностей; *не равно* не следует путать с *неравенством*.

Разница между `==` и `===` — обычно состоит в том, что `==` проверяет на равенство значений, а `===` проверяет на
равенство и значений, и типов. Однако, это не точно. Подходящий способ охарактеризовать их: `==` проверяет на равенство
значений с использованием приведения, а `===` проверяет на равенство, не разрешая приведение. Операцию `===` часто по
этой причине называют "строгое равенство".

Посмотрите на пример неявного приведения, которое допускается нестрогим равенством `==` и не допускается строгим
равенством `===`:

```js
var a = "42";
var b = 42;
a == b;			// true
a === b;		// false
```

В сравнении `a == b` JS замечает, что типы не совпадают, поэтому он делает упорядоченный ряд шагов, чтобы привести одно
или оба значения к другим типам, пока типы не совпадут, а затем уже может быть проверено простое равенство значений.

Если подумать, то есть два возможных пути, когда `a == b` может стать `true` через приведение. Либо сравнение может
закончится на `42 == 42`, либо на `"42" == "42"`. Так какое же из них?

Ответ: `"42"` становится `42`, чтобы сделать сравнение `42 == 42`. В таком простом примере не так уж важно по какому
пути пойдет сравнение, в конце результат будет один и тот же. Есть более сложные случаи, где важно не только каков
конечный результат сравнения, но и *как* вы к нему пришли.

Сравнение `a === b` выдает `false`, так как приведение не разрешено, поэтому простое сравнение значений, очевидно, не
завершится успехом. Многие разработчики чувствуют, что операция `===` — более предсказуема, поэтому они советуют всегда
использовать эту форму и держаться подальше от `==`. Мне кажется, такая точка зрения очень недальновидна. Я верю, что
операция `==` — мощный инструмент, который поможет вашей программе, *если вы уделите время на изучение того, как это
работает.*

Мы не собираемся рассматривать все скучные мельчайшие подробности того, как работает приведение в сравнениях `==`.
Многие из них очень разумные, но есть несколько важных тупиковых ситуаций, с которыми надо быть осторожнее. Чтобы
посмотреть точные правила, загляните в раздел 11.9.3 спецификации ES5 (http://www.ecma-international.org/ecma-262/5.1/):
вы будете удивлены тем, насколько этот механизм прямолинейный, по сравнению со всей этой негативной шумихой вокруг него.

Чтобы свести целое множество деталей к нескольким простым выводам и помочь вам узнать, использовать `==` или `===` в
различных ситуациях, вот мои простые правила:

* Если одно из значений (т.е. сторона) в сравнении может быть значением `true` или `false`, избегайте `==` и
  используйте `===`.
* Если одно из значений в сравнении может быть одним из этих особых значений (`0`, `""` или `[]` — пустой массив),
  избегайте `==` и используйте `===`.
* Во *всех* остальных случаях вы можете безопасно использовать `==`. Это не только безопасно, но во многих случаях это
  упрощает ваш код путем повышения читаемости.

Эти правила сводятся к тому, что требуют от вас критически оценивать свой код и думать о том, какого вида значения могут
исходить из переменных, проверяемых на равенство. Если вы уверены насчет значений, и сравнение `==` — безопасно, то
используйте его! Если вы не уверены насчет значений, используйте `===`. Это просто.

Форма не-равно `!=` идет в паре с `==`, а форма `!==` — в паре с `===`. Все правила и утверждения, которые мы только что
обсудили также применимы для этих сравнений на не равно.

Вам следует обратить особое внимание на правила сравнения `==` и `===`, когда вы сравниваете два непримитивных значения,
таких как `object` (включая `function` и `array`). Так как эти значения на самом деле хранятся по ссылке, оба
сравнения `==` и `===` просто проверяет равны ли ссылки, но ничего не сделают касаемо самих значений.

Например, `массив` по умолчанию приводится к `строке` простым присоединением всех значений с запятыми (`,`) между ними.
Можно было бы подумать, что эти два `массива` с одинаковым содержимым будут равны по `==`, но это не так:

```js
var a = [1, 2, 3];
var b = [1, 2, 3];
var c = "1,2,3";
a == c;		// true
b == c;		// true
a == b;		// false
```

**Примечание:** Детальную информацию о правилах сравнения равенства `==` можно посмотреть в спецификации ES5 (раздел
11.9.3)

#### Неравенство

Операции `<`, `>`, `<=` и `>=`, использующиеся для неравенств, упоминаются в спецификации как "относительное сравнение."
Обычно они используются со значениями, сравниваемыми порядками, как `числа`. Легко понять, что `3 < 4`.

Но `строковые` значения в JavaScript тоже могут участвовать в неравенствах, используя типичные алфавитные
правила (`"bar" < "foo"`).

Как насчет приведения типов? Тут всё похоже на правила в сравнении `==` (хотя и не совсем идентично!). Примечательно,
что нет операций "строгого неравенства", которые запрещали бы приведение таким же путем как и "строгое равенство" `===`.

Пример:

```js
var a = 41;
var b = "42";
var c = "43";
a < b;		// true
b < c;		// true
```

Что здесь происходит? В разделе 11.8.5 спецификации ES5 говорится, что, если оба значения в сравнении `<`
являются `строками`, как это было в случае с `b < c`, то сравнение производится лексикографически (т.е. в алфавитном
порядке, как в словаре), но если одно или оба значения не являются `строками`, как в случае с `a < b`, то оба значения
приводятся к `числу`, и происходит типичное числовое сравнение.

Самое большое затруднение, в которое вы можете попасть со сравнениями между потенциально разными типами значений (
помните, что нет формы "строгого неравенства"?) — это когда одно из значений не может быть превращено в корректное
число, например:

```js
var a = 42;
var b = "foo";
a < b;		// false
a > b;		// false
a == b;		// false
```

Подождите-ка, как это все эти три сравнения могут быть `false`? Так как значение `b` приводится к "некорректному
числовому значению" `NaN` в сравнениях `<` и `>`, а спецификация говорит, что `NaN` не больше и не меньше, чем любое
другое значение.

Сравнение `==` не проходит по другой причине. `a == b` может быть некорректным, если оно интерпретируется
как `42 == NaN` или `"42" == "foo"` — как мы объяснили ранее, первый вариант — наш случай.
