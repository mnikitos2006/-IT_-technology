## Условные операторы

В дополнение к оператору `if`, JavaScript предоставляет несколько других механизмов условных операторов, на которые нам
следует взглянуть.

Иногда вы ловите себя на том, что пишете серию операторов `if..else..if` примерно как тут:

```js
if (a == 2) {
    // сделать что-то
} else if (a == 10) {
    // сделать что-то еще
} else if (a == 42) {
    // сделать еще одну вещь
} else {
    // резервный вариант
}
```

Эта структура работает, но она слишком подробна, поскольку вам нужно указать проверку для `a` в каждом случае. Вот
альтернативная возможность, оператор `switch`:

```js
switch (a) {
    case 2:
        // сделать что-то
        break;
    case 10:
        // сделать что-то еще
        break;
    case 42:
        // сделать еще одну вещь
        break;
    default:
    // резервный вариант
}
```

Оператор `break` важен, если вы хотите, чтобы выполнились операторы только одного `case`. Если вы опустите `break`
в `case` и этот `case` подойдет или выполнится, выполнение продолжится в следующем операторе `case` независимо то того,
подходит ли этот `case`. Этот так называемый "провал (fall through)" иногда полезен/желателен:

```js
switch (a) {
    case 2:
    case 10:
        // какие-то крутые вещи
        break;
    case 42:
        // другие вещи
        break;
    default:
    // резерв
}
```

Здесь если `a` будет либо `2`, либо `10`, то выполнятся операторы "какие-то крутые вещи".

Еще одна форма условного оператора в JavaScript — это "условная операция", часто называемая "тернарная операция". Это
примерно как более краткая форма отдельного оператора `if..else`. Например:

```js
var a = 42;
var b = (a > 41) ? "hello" : "world";
// эквивалентно этому:
// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

Если проверяемое выражение (здесь `a > 41`) вычисляется как `true`, результатом будет первая часть (`"hello"`), в
противном случае результатом будет вторая часть (`"world"`), а затем независимо от результата он будет присвоен
переменной `b`.

Условная операция не обязательно должна использоваться в присваивании, но это самое распространенное ее использование.

## Строгий режим (Strict Mode)

ES5 добавила "строгий режим" в язык, который ужесточил правила для определенных сценариев. В общем-то, эти ограничения
выглядят как большее соответствие кода более безопасному и более подходящему набору рекомендаций. Также, тяготение к
строгому режиму сделает ваш код более оптимизируемым движком. Строгий режим — это большая победа для кода и вам следует
использовать его во всех своих программах.

Вы можете явно указать его для отдельной функции или целого файла, в зависимости от того, где вы разместите директиву
строго режима:

```js
function foo() {
    "use strict";

    // этот код в строгом режиме
    function bar() {
        // этот код в строгом режиме
    }
}

// этот код в нестрогом режиме
```

Сравните с:

```js
"use strict";

function foo() {
    // этот код в строгом режиме
    function bar() {
        // этот код в строгом режиме
    }
}

// этот код в строгом режиме
```

Всего одно ключевое отличие (улучшение!) строго режима — запрет автоматического неявного объявления глобальных
переменных из-за пропуска`var`:

```js
function foo() {
    "use strict";	// включить строгий режим
    a = 1;			// `var` missing, ReferenceError
}

foo();
```

Если вы включаете строгий режим в своем коде и получаете ошибки, или код начинает вести себя ошибочно, у вас может
возникнуть соблазн избегать строго режима. Но потворствовать этому инстинкту — плохая идея. Если строгий режим является
причиной проблем в вашей программе, почти определенно это знак того, что в вашей программе есть вещи, которые надо
исправить.

Строгий режим не только способствует безопасности вашего кода и делает ваш код более оптимизируемым, но и заодно
показывает будущее направление языка. Вам будет легче привыкнуть к строгому режиму сейчас, чем продолжать откладывать
его в сторону — потом код будет сложнее сконвертировать!

## Функции как значения

До сих пор мы обсуждали функции как основной механизм *области видимости* в JavaScript. Вспомните синтаксис типичного
объявления `функции`, указанный ниже:

```js
function foo() {
    // ..
}
```

Хотя это может показаться очевидным из синтаксиса, `foo` — по сути просто переменная во внешней окружающей области
видимости, у которой есть ссылка на объявляемую `функцию`. То есть, `функция` сама является значением, так же как `42`
или `[1,2,3]`.

Это может сперва прозвучать как странная идея, поэтому уделим время ее изучению. Вы не только можете передать значение (
аргумент) *в* функцию, но и *сама функция может быть значением*, которое может быть присвоено переменным, или передано,
или возвращено из других функций.

В связи с этим, о значении-функции следует думать как о выражении, сродни любому другому значению или выражению.

Пример:

```js
var foo = function () {
    // ..
};
var x = function bar() {
    // ..
};
```

Первое функциональное выражение, присваиваемое переменной `foo`, называется *анонимным* поскольку у него нет `имени`.

Второе функциональное выражение *именованное* (`bar`), несмотря на то, что является ссылкой, также присваивается
переменной `x`. *Выражения с именованными функциями* как правило более предпочтительны, хотя *выражения с анонимными
функциями* все еще чрезвычайно употребительны.
