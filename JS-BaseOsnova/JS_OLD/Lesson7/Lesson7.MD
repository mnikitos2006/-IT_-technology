### Методы массивов

Массивы предоставляют множество методов.

### Добавление/удаление элементов

Мы уже знаем методы, которые добавляют и удаляют элементы из начала или конца:

- `arr.push(...items) ` – добавляет элементы в конец,
- ` arr.pop() `– извлекает элемент из конца,
- ` arr.shift()` `– извлекает элемент из начала,
- ` arr.unshift(...items) `– добавляет элементы в начало.

Есть и другие.

### *splice*

Как удалить элемент из массива?

Так как массивы – это объекты, то можно попробовать `delete`:

```js
let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

conslole.log(arr[1]); // undefined

// теперь arr = ["I",  , "home"];
conslole.log(arr.length); // 3
```

Вроде бы, элемент и был удалён, но при проверке оказывается, что массив всё ещё имеет 3 элемента `arr.length == 3`.

Это нормально, потому что всё, что делает `delete obj.key` – это удаляет значение с данным ключом key. Это нормально для
объектов, но для массивов мы обычно хотим, чтобы оставшиеся элементы сдвинулись и заняли освободившееся место. Мы ждём,
что массив станет короче.

Поэтому для этого нужно использовать специальные методы.

Метод `arr.splice(str)`– это универсальный метод для работы с массивами. Умеет всё: добавлять, удалять и
заменять элементы.

```
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

Он начинает с позиции `index`, удаляет `deleteCount` элементов и вставляет `elem1, ..., elemN` на их место. Возвращает
массив
из удалённых элементов.

### Удаление

```js
let arr = ["Я", "изучаю", "JavaScript"];

arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент

conslole.log(arr); // осталось ["Я", "JavaScript"]
```

### Удалим 3 элемента и заменим их двумя другими

```js
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");

conslole.log(arr) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
```

### В этом примере видно, что `splice` возвращает массив из удалённых элементов:

```js

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 2 первых элемента
let removed = arr.splice(0, 2);

conslole.log(removed); // "Я", "изучаю" <-- массив из удалённых элементов
```

### Метод `splice` также может вставлять элементы без удаления, для этого достаточно установить `deleteCount` в 0:

```js

let arr = ["Я", "изучаю", "JavaScript"];

// с позиции 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

conslole.log(arr); // "Я", "изучаю", "сложный", "язык", "JavaScript"
```

Отрицательные индексы разрешены
В этом и в других методах массива допускается использование отрицательного индекса. Он позволяет начать отсчёт элементов
с конца,

### *slice*

Метод `arr.slice` намного проще, чем похожий на него `arr.splice.`

```
arr.slice([start], [end])
```

Он возвращает новый массив, в который копирует элементы, начиная с индекса `start` и до `end` (не включая `end`). Оба
индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.

Это похоже на строковый метод `str.slice`, но вместо подстрок возвращает подмассивы.

```js
let arr = ["t", "e", "s", "t"];

conslole.log(arr.slice(1, 3)); // e,s (копирует с 1 до 3)

conslole.log(arr.slice(-2)); // s,t (копирует с -2 до конца)
```

Можно вызвать `slice` и вообще без аргументов:` arr.slice()` создаёт копию массива arr. Это часто используют, чтобы
создать
копию массива для дальнейших преобразований, которые не должны менять исходный массив.

### *concat*

Метод `arr.concat` создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

Его синтаксис:

```
arr.concat(arg1, arg2...)
```

Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.

В результате мы получаем новый массив, включающий в себя элементы из arr, а также `arg1, arg2 и так далее…`

Если аргумент `argN `– массив, то все его элементы копируются. Иначе скопируется сам аргумент.

Например: 

```js


let arr = [1, 2];

// создать массив из: arr и [3,4]
console.log(arr.concat([3, 4])); // [1,2,3,4]

// создать массив из: arr и [3,4] и [5,6]
console.log(arr.concat([3, 4], [5, 6])); // [1,2,3,4,5,6]

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
console.log(arr.concat([3, 4], 5, 6)); // [1,2,3,4,5,6]

```

Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как
есть:

```js
let arr = [1, 2];

let arrayLike = {
    0: "что-то",
    length: 1
};

console.log(arr.concat(arrayLike)); // [1,2, {0: "что-то",length: 1}]

```

### *Перебор: forEach*

Метод `arr.forEach` позволяет запускать функцию для каждого элемента массива.

Его синтаксис:

```
arr.forEach(function(item, index, array) {
// ... делать что-то с item
});
```

Например, этот код выведет на экран каждый элемент массива:

```js
// Вызов console.log для каждого элемента
["Bilbo", "Gandalf", "Nazgul"].forEach(console.log);
```

А этот вдобавок расскажет и о своей позиции в массиве:

```js

["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
    console.log(`${item} имеет позицию ${index} в ${array}`);
});
```

Результат `forEach` *undefined* т.е НИЧЕГО НЕВОЗВРАЩАЕТ

### Поиск в массиве

#### indexOf/lastIndexOf и includes

Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути то же самое, что и их
строковые аналоги, но работают с элементами вместо символов:

- `arr.indexOf(item, from)` ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый
  элемент, в противном случае -1.
- `arr.lastIndexOf(item, from)` – то же самое, но ищет справа налево.
- `arr.includes(item, from)` – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

```js
let arr = [1, 0, false];

console.log(arr.indexOf(0)); // 1
console.log(arr.indexOf(false)); // 2
console.log(arr.indexOf(null)); // -1

console.log(arr.includes(1)); // true
```

Обратите внимание, что методы используют строгое сравнение `===`. Таким образом, если мы ищем `false`, он находит именно
`false`, а не ноль.

Если мы хотим проверить наличие элемента, и нет необходимости знать его точный индекс, тогда предпочтительным является
`arr.includes`.

Кроме того, очень незначительным отличием `includes` является то, что он правильно обрабатывает NaN в отличие от
`indexOf/lastIndexOf`:

```js
const arr = [NaN];
conslole.log(arr.indexOf(NaN)); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
conslole.log(arr.includes(NaN));// true (верно)
```

### *find и findIndex*

Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?

Здесь пригодится метод `arr.find`.

Его синтаксис таков:

```js
let result = arr.find(function (item, index, array) {
    // если true - возвращается текущий элемент и перебор прерывается
    // если все итерации оказались ложными, возвращается undefined
});
```

Функция вызывается по очереди для каждого элемента массива:

- `item` – очередной элемент.
- `index` – его индекс.
- `array` – сам массив.

Если функция возвращает `true`, поиск прерывается и возвращается `item`. Если ничего не найдено,
возвращается `undefined`.

Например, у нас есть массив пользователей, каждый из которых имеет поля `id и name`. Попробуем найти того, кто
с `id == 1`:

```js
let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

console.log(user.name); // Вася
```

В реальной жизни массивы объектов – обычное дело, поэтому метод find крайне полезен.

Обратите внимание, что в данном примере мы передаём `find` функцию `item => item.id == 1`, с одним аргументом. Это
типично,
дополнительные аргументы этой функции используются редко.

Метод `arr.findIndex` – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и
-1,
если ничего не найдено.

### *filter*

Метод `find` ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт `true`.

На тот случай, если найденных элементов может быть много, предусмотрен метод `arr.filter(fn)`.

Синтаксис этого метода схож с `find`, но `filter` возвращает массив из всех подходящих элементов:

```js

let results = arr.filter(function (item, index, array) {
    // если true - элемент добавляется к результату, и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
});
```

```js
let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

console.log(someUsers.length); // 2
```

### Преобразование массива

Метод `arr.map` является одним из наиболее полезных и часто используемых.

Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

```js
let result = arr.map(function (item, index, array) {
    // возвращается новое значение вместо элемента
});
```

```js
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
conslole.log(lengths); // 5,7,6
```

### *sort(fn)*

Вызов `arr.sort()` сортирует массив на месте, меняя в нём порядок элементов.

Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.

```js
let arr = [1, 2, 15];

// метод сортирует содержимое arr
arr.sort();

console.log(arr);  // 1, 15, 2
```

Не заметили ничего странного в этом примере?

Порядок стал 1, 15, 2. Это неправильно! Но почему?

По умолчанию элементы сортируются как строки.

Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок, и
действительно выходит, что ``"2" > "15"``.

Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента `arr.sort()`.

Функция должна для пары значений возвращать:

```js
function compare(a, b) {
    if (a > b) return 1; // если первое значение больше второго
    if (a == b) return 0; // если равны
    if (a < b) return -1; // если первое значение меньше второго
}
```

Например, для сортировки чисел:

```js
function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
}

let arr = [1, 2, 15];

arr.sort(compareNumeric);

console.log(arr);  // 1, 2, 15
```

Упомянутый ранее массив arr может быть массивом чего угодно, верно? Он может содержать числа, строки, объекты или что-то
ещё. У нас есть набор каких-то элементов. Чтобы отсортировать его, нам нужна функция, определяющая порядок, которая
знает, как сравнивать его элементы. По умолчанию элементы сортируются как строки.

Метод arr.sort(fn) реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает внутри (в
большинстве случаев это оптимизированная быстрая сортировка или Timsort). Она проходится по массиву, сравнивает его
элементы с помощью предоставленной функции и переупорядочивает их. Всё, что остаётся нам, это предоставить fn, которая
делает это сравнение.

Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – ничто не мешает нам вывести их на экран:

```js
[1, -2, 15, 2, 0, 8].sort(function (a, b) {
    console.log(a + " <> " + b);
    return a - b;
});
```

На самом деле от функции сравнения требуется любое положительное число, чтобы сказать` «больше»`, и отрицательное число,
чтобы сказать `«меньше»`.

Это позволяет писать более короткие функции:

```js
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

console.log(arr);  // 1, 2, 15
```

Можно использовать их здесь для того, чтобы сортировка выглядела более аккуратной:

```js
arr.sort( (a, b) => a - b );
```