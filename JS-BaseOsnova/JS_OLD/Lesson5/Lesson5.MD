# Переменные

В JavaScript имена переменных (включая имена функций) должны быть корректными *идентификаторами*. Строгие и полные
правила о корректных символах в идентификаторах — немного сложны, когда вы хотите использовать нестандартные символы,
такие как Unicode-символы. Если вы собираетесь использовать только типичные буквенно-цифровые ASCII-символы, то правила
просты.

Идентификатор должен начинаться с `a`-`z`, `A`-`Z`, `$` или `_`. Дальше он может содержать любые из этих же символов и
цифры `0`-`9`.

В общем-то, те же правила, как и к идентификатору переменной, применяются и к имени свойства. Однако, определенные слова
не могут использоваться как переменные, но могут использоваться в качестве имен свойств. Эти слова называются"
зарезервированными словами", и включают ключевые слова JS (`for`, `in`, `if` и т.д.), так же как и `null`, `true`
и `false`.

### Области видимости функций

Вы используете ключевое слово `var`, чтобы объявить переменную, которая принадлежит области видимости текущей функции
или глобальной области, если находится на верхнем уровне вне любой функции.

#### Поднятие переменной (hoisting)

Где бы ни появлялось `var` внутри области видимости, это объявление принадлежит всей области видимости и доступно в
любом месте внутри области.

Метафорически это поведение называется *поднятие (hoisting)*, когда объявление `var` концептуально "перемещается" на
вершину своей объемлющей области видимости. Технически этот процесс более точно объясняется тем, как компилируется код,
но сейчас опустим эти подробности.

Пример:

```js
var a = 2;
foo();					// работает, так как определение `foo()`
// "всплыло"
function foo() {
    a = 3;
    console.log(a);	// 3
    var a;				// определение "всплыло"
    // наверх `foo()`
}

console.log(a);	// 2
```

**Предупреждение:** Не общепринято и не так уж здраво полагаться на *поднятие* переменной, чтобы использовать переменную
раньше в ее области видимости, чем появится ее объявление с `var`: такое может сбить с толку. Общепринято и приемлемо
использовать *всплытие* объявлений функций, что мы и делали с вызовом `foo()`, появившемся до ее объявления.

#### Вложенные области видимости

Когда вы объявляете переменную, она доступна везде в ее области видимости, так же как и в более нижних/внутренних
областях видимости. Например:

```js
function foo() {
    var a = 1;

    function bar() {
        var b = 2;

        function baz() {
            var c = 3;
            console.log(a, b, c);	// 1 2 3
        }

        baz();
        console.log(a, b);		// 1 2
    }

    bar();
    console.log(a);				// 1
}

foo();
```

Заметьте, что `c` не доступна внутри `bar()`, потому что она объявлена только внутри внутренней области
видимости `baz()` и `b` не доступна в `foo()` по той же причине.

Если вы попытаетесь получить доступ к значению переменной в области видимости, где она уже недоступна, вы
получите `ReferenceError`. Если вы попытаетесь установить значение переменной, которая еще не объявлена, все либо
закончится тем, что переменная создастся в самой верхней глобальной области видимости (плохо!), либо получите ошибку в
зависимости от "строгого режима" (см. "Строгий режим"). Давайте взглянем:

```js
function foo() {
    a = 1;	// `a` формально не объявлена
}

foo();
a;			// 1 — упс, автоматическая глобальная переменная :(
```

Это очень плохая практика. Не делайте так! Всегда явно объявляйте свои переменные.

В дополнение к созданию объявлений переменных на уровне функций, ES6 *позволяет* вам объявлять переменные, принадлежащие
отдельным блокам (пара `{ .. }`), используя ключевое слово `let`. Кроме некоторых едва уловимых деталей, правила области
видимости будут вести себя точно так же, как мы видели в функциях:

```js
function foo() {
    var a = 1;
    if (a >= 1) {
        let b = 2;
        while (b < 5) {
            let c = b * 2;
            b++;
            console.log(a + c);
        }
    }
}

foo();
// 5 7 9
```

Из-за использования `let` вместо `var`, `b` будет принадлежать только оператору `if` и следовательно не всей области
видимости функции `foo()`. Точно так же `c` принадлежит только циклу `while`. Блочная область видимости очень полезна
для управления областями ваших переменных более точно, что может сделать ваш код более легким в обслуживании в
долгосрочной перспективе.

## Условные операторы

В дополнение к оператору `if`, JavaScript предоставляет несколько других механизмов условных операторов, на которые нам
следует взглянуть.

Иногда вы ловите себя на том, что пишете серию операторов `if..else..if` примерно как тут:

```js
if (a == 2) {
    // сделать что-то
} else if (a == 10) {
    // сделать что-то еще
} else if (a == 42) {
    // сделать еще одну вещь
} else {
    // резервный вариант
}
```

Эта структура работает, но она слишком подробна, поскольку вам нужно указать проверку для `a` в каждом случае. Вот
альтернативная возможность, оператор `switch`:

```js
switch (a) {
    case 2:
        // сделать что-то
        break;
    case 10:
        // сделать что-то еще
        break;
    case 42:
        // сделать еще одну вещь
        break;
    default:
    // резервный вариант
}
```

Оператор `break` важен, если вы хотите, чтобы выполнились операторы только одного `case`. Если вы опустите `break`
в `case` и этот `case` подойдет или выполнится, выполнение продолжится в следующем операторе `case` независимо то того,
подходит ли этот `case`. Этот так называемый "провал (fall through)" иногда полезен/желателен:

```js
switch (a) {
    case 2:
    case 10:
        // какие-то крутые вещи
        break;
    case 42:
        // другие вещи
        break;
    default:
    // резерв
}
```

Здесь если `a` будет либо `2`, либо `10`, то выполнятся операторы "какие-то крутые вещи".

Еще одна форма условного оператора в JavaScript — это "условная операция", часто называемая "тернарная операция". Это
примерно как более краткая форма отдельного оператора `if..else`. Например:

```js
var a = 42;
var b = (a > 41) ? "hello" : "world";
// эквивалентно этому:
// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

Если проверяемое выражение (здесь `a > 41`) вычисляется как `true`, результатом будет первая часть (`"hello"`), в
противном случае результатом будет вторая часть (`"world"`), а затем независимо от результата он будет присвоен
переменной `b`.

Условная операция не обязательно должна использоваться в присваивании, но это самое распространенное ее использование.

## Строгий режим (Strict Mode)

ES5 добавила "строгий режим" в язык, который ужесточил правила для определенных сценариев. В общем-то, эти ограничения
выглядят как большее соответствие кода более безопасному и более подходящему набору рекомендаций. Также, тяготение к
строгому режиму сделает ваш код более оптимизируемым движком. Строгий режим — это большая победа для кода и вам следует
использовать его во всех своих программах.

Вы можете явно указать его для отдельной функции или целого файла, в зависимости от того, где вы разместите директиву
строго режима:

```js
function foo() {
    "use strict";

    // этот код в строгом режиме
    function bar() {
        // этот код в строгом режиме
    }
}

// этот код в нестрогом режиме
```

Сравните с:

```js
"use strict";

function foo() {
    // этот код в строгом режиме
    function bar() {
        // этот код в строгом режиме
    }
}

// этот код в строгом режиме
```

Всего одно ключевое отличие (улучшение!) строго режима — запрет автоматического неявного объявления глобальных
переменных из-за пропуска`var`:

```js
function foo() {
    "use strict";	// включить строгий режим
    a = 1;			// `var` missing, ReferenceError
}

foo();
```

Если вы включаете строгий режим в своем коде и получаете ошибки, или код начинает вести себя ошибочно, у вас может
возникнуть соблазн избегать строго режима. Но потворствовать этому инстинкту — плохая идея. Если строгий режим является
причиной проблем в вашей программе, почти определенно это знак того, что в вашей программе есть вещи, которые надо
исправить.

Строгий режим не только способствует безопасности вашего кода и делает ваш код более оптимизируемым, но и заодно
показывает будущее направление языка. Вам будет легче привыкнуть к строгому режиму сейчас, чем продолжать откладывать
его в сторону — потом код будет сложнее сконвертировать!

## Функции как значения

До сих пор мы обсуждали функции как основной механизм *области видимости* в JavaScript. Вспомните синтаксис типичного
объявления `функции`, указанный ниже:

```js
function foo() {
    // ..
}
```

Хотя это может показаться очевидным из синтаксиса, `foo` — по сути просто переменная во внешней окружающей области
видимости, у которой есть ссылка на объявляемую `функцию`. То есть, `функция` сама является значением, так же как `42`
или `[1,2,3]`.

Это может сперва прозвучать как странная идея, поэтому уделим время ее изучению. Вы не только можете передать значение (
аргумент) *в* функцию, но и *сама функция может быть значением*, которое может быть присвоено переменным, или передано,
или возвращено из других функций.

В связи с этим, о значении-функции следует думать как о выражении, сродни любому другому значению или выражению.

Пример:

```js
var foo = function () {
    // ..
};
var x = function bar() {
    // ..
};
```

Первое функциональное выражение, присваиваемое переменной `foo`, называется *анонимным* поскольку у него нет `имени`.

Второе функциональное выражение *именованное* (`bar`), несмотря на то, что является ссылкой, также присваивается
переменной `x`. *Выражения с именованными функциями* как правило более предпочтительны, хотя *выражения с анонимными
функциями* все еще чрезвычайно употребительны.

### Выражения немедленно вызываемых функций (Immediately Invoked Function Expressions (IIFEs))

В предыдущем примере ни одно из выражений с функциями не выполнялось, мы могли бы это сделать, включив в код `foo()`
или `x()`, например.

Есть еще один способ выполнить выражение с функцией, на который обычно ссылаются как на *immediately invoked function
expression* (IIFE):

```js
(function IIFE() {
    console.log("Hello!");
})();
// "Hello!"
```

Внешние `( .. )`, которые окружают выражение функции `(function IIFE(){ .. })`, — это всего лишь нюанс грамматики JS,
необходимый для предотвращения того, чтобы это выражение воспринималось как объявление обычной функции.

Последние `()` в конце выражения, строка `})();` — это то, что и выполняет выражение с функцией, указанное сразу перед
ним.

Может показаться странным, но это не так уж чужеродно, как кажется на первый взгляд. Посмотрите на сходства между `foo`
и `IIFE` тут:

```js
function foo() { ..
}

// `foo` выражение со ссылкой на функцию,
// затем `()` выполняют ее
foo();
// Выражение с функцией `IIFE`,
// затем `()` выполняют ее
(function IIFE() { ..
})();
```

Как видите, содержимое `(function IIFE(){ .. })` до ее вызова в `()`  фактически такое же, как включение `foo` до его
вызова после `()`. В обоих случаях ссылка на функцию выполняется с помощью `()` сразу после них.

Так как IIFE — просто функция, а функции создают *область видимости* переменных, то использование IIFE таким образом
обычно происходит, чтобы объявлять переменные, которые не будут влиять на код, окружающий IIFE снаружи:

```js
var a = 42;
(function IIFE() {
    var a = 10;
    console.log(a);	// 10
})();
console.log(a);		// 42
```

Функции IIFE также могут возвращать значения:

```js
var x = (function IIFE() {
    return 42;
})();
x;	// 42
```

Значение `42` `возвращается` из выполненной `IIFE` функции, а затем присваивается в `x`.

## Идентификатор `this`

Еще одна очень часто неверно понимаемая концепция в JavaScript — это идентификатор `this`. Опять таки, есть пара глав по
нему в книге *this и прототипы объектов* этой серии, поэтому здесь мы только кратко его рассмотрим.

При том что может часто казаться, что ключевое слово `this` связано с "объектно-ориентированным шаблонами", в JS `this`
— это другой механизм.

Если у функции есть внутри ссылка `this`, эта ссылка `this` обычно указывает на `объект`. Но на какой `объект` она
указывает зависит от того, как эта функция была вызвана.

Важно понимать, что `this` *не* ссылается на саму функцию, хотя это самое распространенное неверное представление.

Вот краткая иллюстрация:

```js
function foo() {
    console.log(this.bar);
}

var bar = "global";
var obj1 = {
    bar: "obj1",
    foo: foo
};
var obj2 = {
    bar: "obj2"
};
//--------
foo();				// "global"
obj1.foo();			// "obj1"
foo.call(obj2);	// "obj2"
new foo();			// undefined
```

Есть четыре правила того, как устанавливается `this`, и они показаны в этих четырех последних строках кода.

1. `foo()` присваивает в `this` ссылку на глобальный объект в нестрогом режиме. В строгом режиме, `this`
   будет `undefined`, и вы получите ошибку при доступе к свойству `bar`, поэтому `"global"` — это значение
   для `this.bar`.
2. `obj1.foo()` устанавливает `this` в объект `obj1`.
3. `foo.call(obj2)` устанавливает `this` в объект `obj2`.
4. `new foo()` устанавливает `this` в абсолютно новый пустой объект.

Резюме: чтобы понять, на что указывает `this`, вам нужно проверить, как именно вызывалась функция. Это будет один из тех
четырех вышеописанных способов, таким образом вы поймете, что будет в `this`.

**Примечание:** Более детальная информация о ключевом слове `this` есть в главах 1 и 2 книги *this и прототипы объектов*
этой серии.