# Блоки

В коде нам часто нужно сгруппировать последовательности операторов вместе, которые мы часто называем *
блоками*. В JavaScript блок определяется оборачиванием одного или более операторов парой фигурных скобок `{ .. }`.
Пример:

```js
var amount = 99.99;
// отдельный блок
{
    amount = amount * 2;
    console.log(amount);	// 199.98
}
```

Такой вид отдельного блока `{ .. }` вполне допустим, но не часто встречается в JS-программах. Обычно блоки
присоединяются к другим управляющим операторам, таким как оператор `if`

```js
var amount = 99.99;
// сумма достаточно велика?
if (amount > 10) {			// <-- блок прикрепляется к `if`
    amount = amount * 2;
    console.log(amount);	// 199.98
}
```

Блок `{ .. }` с двумя операторами присоединен к `if (amount > 10)`. Операторы внутри этого блока будут выполнены только
при истинности выражения в условной конструкции.

Есть несколько способов выражения *условных конструкций* (т.е. выбора) в наших программах.

Самый распространенный из них — это оператор `if`. По сути, вы говорите, «*Если* (*if*) это условие истинно, сделать
следующее...». Например:

```js
var bank_balance = 302.13;
var amount = 99.99;
if (amount < bank_balance) {
    console.log("Я хочу купить этот телефон");
}
```

Оператор `if` требует выражение между скобками `( )`, которое может быть интерпретировано либо как `истина` (`true`),
либо как `ложь` (`false`). В этой программе мы написали выражение `amount < bank_balance`, которое конечно же будет
вычислено как `true` или `false` в зависимости от значения переменной `bank_balance`.

Вы даже можете предоставить альтернативу программе, в случае если условие не будет истинным, описываемую
оператором `else`. Пример:

```js
const ACCESSORY_PRICE = 9.99;
var bank_balance = 302.13;
var amount = 99.99;
amount = amount * 2;
// может ли мы позволить себе дополнительную покупку?
if (amount < bank_balance) {
    console.log("Я возьму этот аксессуар!");
    amount = amount + ACCESSORY_PRICE;
}
// иначе:
else {
    console.log("Нет, спасибо.");
}
```

Если `amount < bank_balance` - `истинно`, выведем `"Я возьму этот аксессуар!"` и добавим `9.99` в нашу
переменную `amount`. В противном случае оператор `else` говорит, что мы вежливо ответим `"Нет, спасибо."` и оставим
переменную `amount` без изменений.

Как мы уже обсуждали ранее, значения, которые не совпадают с ожидаемым типом, часто приводятся к этому типу.
Оператор `if` ожидает `логическое значение`, но если вы передадите что-либо отличное от `логического значения`,
произойдет неявное приведение типов.

JavaScript определяет список особых значений, которые считаются «как бы ложными», так как при приведении
к `логическому значению` они примут значение `false`; такой список включает в себя `0` и `""`. Любое другое значение, не
входящее в список «как бы ложных», автоматически считается «как бы истинным»: при приведении к `логическому значению`
оно становится равным `true`. Истинными, например, являются значения `99.99` и `"free"`. См. «Истинный и ложный» в главе
2 для получения более детальной информации.

*Условные конструкции* существуют и в других формах, отличных от `if`. Например, оператор `switch` может использоваться
в качестве сокращения для последовательности операторов `if..else` . Циклы используют *
условную конструкцию*, чтобы определить завершать выполнение или нет.

## Циклы

При большой занятости магазина образуется очередь из покупателей, которым нужно поговорить с сотрудником магазина. Пока
в этой очереди есть люди, сотруднику нужно продолжать обслуживать очередного покупателя.

Повторение набора действий пока не нарушится определенное условие, или другими словами, повторение только пока
соблюдается условие — это как раз работа для циклов. Циклы могут принимать различные формы, но все они удовлетворяют
этому базовому поведению.

Цикл включает в себя проверяемое условие и блок (обычно в виде `{ .. }`). Процесс каждого выполнения блока в цикле
называется *итерацией*.

Например, цикл `while` и цикл `do..while` иллюстрируют принцип повторения блока выражений до тех пор, пока условие не
перестанет быть равным `true`:

```js
while (numOfCustomers > 0) {
    console.log("Чем я могу вам помочь?");
    // помощь покупателю...
    numOfCustomers = numOfCustomers - 1;
}
// против:
do {
    console.log("Чем я могу вам помочь?");
    // помощь покупателю...
    numOfCustomers = numOfCustomers - 1;
} while (numOfCustomers > 0);
```

Единственной разницей между этими циклами является проверка условия до первой итерации (`while`) или после первой
итерации (`do..while`).

Если в любом из этих циклов условная конструкция возвратит `false`, то следующая итерация не будет выполнена. Это
означает, что, если условие изначально будет `false`, цикл `while` никогда не будет выполнен, а цикл `do..while`
выполнится только один раз.

Иногда вы используете цикл для подсчета определенного набора чисел, например, от `0` до `9` (десять чисел). Это можно
сделать присвоением переменной итерации, например, `i` значения `0`, а затем увеличением ее на `1` в каждой итерации.

**Предупреждение:** По множеству исторических причин языки программирования почти всегда ведут подсчет, начиная с `0`
вместо `1`.

Условная конструкция проверяется на каждой итерации, как если бы был неявный оператор `if` внутри цикла.

Для выхода из цикла можно использовать оператор `break`. К тому же, можно обнаружить, что ужасно легко можно создать
цикл, который без механизма  `break` будет работать вечно.

Проиллюстрируем:

```js
var i = 0;
// цикл `while..true` будет выполняться вечно, не так ли?
while (true) {
    // прервать цикл?
    if ((i <= 9) === false) {
        break;
    }
    console.log(i);
    i = i + 1;
}
// 0 1 2 3 4 5 6 7 8 9
```

**Предупреждение:** Показанное выше не является практикой, которой вам необходимо придерживаться при реализации ваших
циклов. Это представлено только в иллюстративных целях.

Если `while` (или `do..while`) может достичь цели вручную, есть еще одна синтаксическая форма, называемая циклом `for`,
подходящая именно для такой цели:

```js
for (var i = 0; i <= 9; i = i + 1) {
    console.log(i);
}
// 0 1 2 3 4 5 6 7 8 9
```

Как видите, в обоих случаях условная конструкция `i <= 9` равна `true` для первых 10 итераций (`i` принимает значения
от `0` до `9`) для любой из форм цикла, но становится равной `false`, как только переменная `i` становится равной `10`.

У цикла `for` есть три составных части: инициализация (`var i=0`), проверка условия (`i <= 9`) и обновление
значения (`i = i + 1`). Поэтому, если вы собираетесь заниматься выполнением конкретного количества итераций, `for` будет
более компактной и зачастую более легкой формой цикла для понимания и записи.

Есть и другие особые формы циклов, которые предназначены для итерирования по особым значениям, таким как свойства
объекта, где неявная проверка условной конструкции — это все ли свойства уже обработаны. Принцип «цикл
работает пока не нарушится условие» соблюдается независимо от формы цикла.

## Функции

Сотрудник магазина, возможно, не носит постоянно с собой калькулятор, чтобы учесть налоги и рассчитать окончательную
стоимость покупки. Это задача, которую ему нужно определить один раз и использовать раз за разом. Преимущество в том,
что у компании есть контрольно-кассовый аппарат (компьютер, планшет и т.п.), в который эти «функции» уже встроены.

Похожим образом и в вашей программе вам определенно захочется разбить задачи в коде на повторно используемые части,
вместо того, чтобы снова и снова однообразно повторять себя. Для реализации этого необходимо определить `функцию`.

Обычно функция — это именованная секция кода, которая может быть «вызвана» по имени, и код внутри нее будет при этом
запускаться при каждом вызове. Пример:

```js
function printAmount() {
    console.log(amount.toFixed(2));
}

var amount = 99.99;
printAmount(); // "99.99"
amount = amount * 2;
printAmount(); // "199.98"
```

У функций могут быть аргументы (т.е. параметры) — это значения, которые вы ей передаете. А также функции могут
возвращать значение.

```js
function printAmount(amt) {
    console.log(amt.toFixed(2));
}

function formatAmount() {
    return "$" + amount.toFixed(2);
}

var amount = 99.99;
printAmount(amount * 2);		// "199.98"
amount = formatAmount();
console.log(amount);			// "$99.99"
```

Функция `printAmount(..)` принимает параметр, который мы назвали `amt`. Функция `formatAmount()` возвращает значение.
Конечно, вы можете комбинировать параметры и возвращаемое значение в одной и той же функции.

Функции часто используются для кода, который вы планируете вызывать несколько раз, но они также полезны для организации
связанных частей кода в именованные наборы, даже если вы вызовете их всего лишь раз.

Пример:

```js
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
    // вычисляем новую сумму с налогом
    amt = amt + (amt * TAX_RATE);
    // возвращаем новую сумму
    return amt;
}

var amount = 99.99;
amount = calculateFinalPurchaseAmount(amount);
console.log(amount.toFixed(2));		// "107.99"
```

Хотя `calculateFinalPurchaseAmount(..)` вызывается только один раз, выделение её поведения в отдельную именованную
функцию делает код, использующий её логику (оператор `amount = calculateFinal...`), яснее. Если в функции есть несколько
операторов, то её преимущества будут более очевидны.

### Область видимости

Если вы попросите у продавца модель телефона, которой у магазина нет в продаже, то он не сможет продать вам телефон,
который вы хотите. У него есть доступ только к телефонам, которые есть в наличии в магазине. Вам нужно найти другой
магазин, чтобы посмотреть, есть ли в нем нужный вам телефон.

В программировании есть термин для этого принципа: *область видимости* (технически называемая *лексическая область
видимости*). В JavaScript каждая функция получает свою собственную область видимости. Областью видимости является
коллекция переменных и правила доступа к этим переменным по имени. Только код внутри функции имеет доступ к
переменным, *определенным в ее области видимости*.

Имя переменной должно быть уникальным в рамках одной и той же области видимости: не может быть двух различных
переменных `a`, расположенных рядом друг с другом. Но одно и тоже имя переменной `a` может появляться в разных областях
видимости.

```js
function one() {
    // эта `a` принадлежит только функции `one()`
    var a = 1;
    console.log(a);
}

function two() {
    // эта `a` принадлежит только функции `two()`
    var a = 2;
    console.log(a);
}

one();		// 1
two();		// 2
```

Также, область видимости может быть вложена внутрь другой области видимости, прямо как клоун на дне рождения надувает
один шарик внутри другого. Если одна область вложена в другую, для кода внутри самой внутренней области доступны
переменные из окружающей области.

Пример:

```js
function outer() {
    var a = 1;

    function inner() {
        var b = 2;
        // здесь у нас есть доступ и к `a`, и к `b`
        console.log(a + b);	// 3
    }

    inner();
    // здесь у нас есть доступ только к  `a`
    console.log(a);			// 1
}

outer();
```

Правила лексической области видимости говорят, что код в одной области может иметь доступ к переменным как её самой, так
и к переменным любой области снаружи этой области.

Таким образом, код внутри функции `inner()` имеет доступ к обеим переменным `a` и `b`, но у кода в `outer()` есть доступ
только к `a` — у него нет доступа к `b`, потому что эта переменная внутри `inner()`.

Вспомните этот код, который появлялся выше:

```js
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
    // вычисляем новую сумму с налогом
    amt = amt + (amt * TAX_RATE);
    // возвращаем новую сумму
    return amt;
}
```

Константа (переменная) `TAX_RATE` доступна внутри функции `calculateFinalPurchaseAmount(..)`, даже несмотря на то, что
мы не передавали её внутрь, из-за лексической области видимости.

## Практика

Нет абсолютно никакой равноценной замены практике при обучении программированию. Никакое, даже самое ясное, описание с
моей стороны само по себе не сделает из вас программиста.

Держа это в уме, давайте попробуем попрактиковаться в некоторых принципах, которые мы изучили. Я дам вам
«требования», а вы попробуете их реализовать. Затем сверьтесь с кодом, приведенным ниже, чтобы увидеть, как реализовал
их я.

* Напишите программу для вычисления общей стоимости покупки телефона. Вы будете продолжать покупать телефоны (подсказка:
  циклы!), пока у вас не закончатся деньги на банковском счете. Вы также будете покупать аксессуары для каждого из
  телефонов до тех пор, пока сумма покупки не превысит ваш мысленный предел трат.
* После того, как вы посчитаете сумму покупки, прибавьте налог, затем выведите на экран вычисленную сумму покупки,
  правильно отформатировав её.
* Наконец, сверьте сумму с балансом вашего банковского счета, чтобы понять можете вы себе это позволить или нет.
* Вы должны настроить некоторые константы для «ставки налога», «цены телефона», «цены аксессуара» и «предела трат»,
  также как и переменную для вашего «баланса банковского счета».
* Вам следует определить функции для вычисления налога и для форматирования цены со знаком валюты и округлением до двух
  знаков после запятой.
* **Бонусная задача:** Попробуйте включить ввод данных в вашу программу, например с помощью функции `prompt(..)`,
  рассмотренной ранее в разделе «Ввод». Вы можете, например, запросить у пользователя баланс банковского счета.
  Развлекайтесь и будьте изобретательны!

Х
Вот мое решение для этого упражнения, написанное на JavaScript:

```js
const SPENDING_THRESHOLD = 200;
const TAX_RATE = 0.08;
const PHONE_PRICE = 99.99;
const ACCESSORY_PRICE = 9.99;
var bank_balance = 303.91;
var amount = 0;

function calculateTax(amount) {
    return amount * TAX_RATE;
}

function formatAmount(amount) {
    return "$" + amount.toFixed(2);
}

// продолжаем покупать телефоны пока у нас остаются деньги
while (amount < bank_balance) {
    // покупаем новый телефон!
    amount = amount + PHONE_PRICE;
    // можем ли мы позволить себе аксессуар?
    if (amount < SPENDING_THRESHOLD) {
        amount = amount + ACCESSORY_PRICE;
    }
}
// не забудьте заплатить налог
amount = amount + calculateTax(amount);
console.log(
    "Ваша покупка: " + formatAmount(amount)
);
// Ваша покупка: $334.76
// можете ли вы в самом деле позволить себе эту покупку?
if (amount > bank_balance) {
    console.log(
        "Вы не можете позволить себе эту покупку. :("
    );
}
// Вы не можете позволить себе эту покупку. :(
```

**Примечание:** Простейший способ запустить эту JavaScript программу — набрать её в консоли разработчика в вашем
браузере.

Как ваши успехи? Не помешало бы попробовать еще раз после того, как вы увидели мой код. Также попробуйте поиграть с
изменением констант, чтобы увидеть работу программы с разными значениями.

