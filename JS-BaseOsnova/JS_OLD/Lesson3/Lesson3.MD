# Введение в JavaScript

## Значения и типы

В JavaScript типизированные  **ЗНАЧЕНИЯ**, а не типизированные переменные. Доступны следующие встроенные типы:

* `string` (строка)
* `number` (число)
* `bigint` (целые числа произвольной длинны)
* `boolean` (логическое значение)
* `null`  (пустое значение)
* `undefined` (пустое значение)
* `object` (объект)
* `symbol` (символ, новое в ES6)

JavaScript предоставляет операцию `typeof`, которая оценивает значение и сообщает вам, какого оно типа:

```js
var a;

typeof a;                  // "undefined"

a = "hello world";
typeof a;				// "string"

a = 42;
typeof a;				// "number"

a = true;
typeof a;				// "boolean"

a = null;
typeof a;				// "object" — черт, ошибка

a = undefined;
typeof a;				// "undefined"

a = {b: "c"};
typeof a;				// "object"

a = Symbol();
typeof a;                               // "symbol"

a = BigInt();
typeof a;                               // "bigint"
```

Значение, возвращаемое операцией `typeof`, всегда одно из 8 строковых значений. Это
значит, что `typeof "abc"` вернет `"string"`, а не `string`.

Обратите внимание, что в этом коде переменная `a` хранит значения каждого из типов, и несмотря на видимость, `typeof a`
спрашивает не "тип `a`", а "тип текущего значения в `a`." Только у значений есть типы в JavaScript, переменные являются
всего лишь контейнерами для этих значений.

`typeof null` — это интересный случай, так как он ошибочно возвращает `"object"`, тогда как вы ожидали бы, что он
вернет `"null"`.

**Предупреждение:** Это давний баг в JS, но, похоже, он никогда не будет исправлен. Слишком много кода в интернете
полагается на него, и его исправление повлечет за собой намного больше ошибок!

Также обратите внимание на `a = undefined`. Мы явно установили `a` в значение `undefined`, и она по поведению не
отличается от переменной, у которой еще не установлено значение, например, как тут `var a;`, в строке в начале блока
кода. Переменная может получать такое состояние значения "undefined" разными способами, включая функции, которые не
возвращают значения, или использованием операции `void`.

### Объекты

Тип `object` указывает на составное значение, в котором вы можете устанавливать свойства (именованные области), хранящие
свои собственные значения любого типа. Это, может быть, один из самых полезных типов значений во всем JavaScript.

```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};
obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true
obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```

Полезно представить значение этого `obj` визуально:

<img src="fig4.png">

Свойства могут быть доступны либо через *точечную нотацию* (т.е. `obj.a`), либо через *скобочную нотацию* (
т.е. `obj["a"]`). Точечная нотация короче и в целом легче для чтения, и, следовательно, ей следует по возможности
отдавать предпочтение.

Скобочная нотация полезна, если у вас есть имя свойства, содержащее спецсимволы, например `obj["hello world!"]` — такие
свойства часто называют  *ключами*, когда к ним обращаются с помощью скобочной нотации. Нотация `[ ]` требует либо
переменную (поясняется ниже), либо `строковый` *литерал* (который должен быть заключен в `" .. "` или `' .. '`).

Конечно, скобочная нотация также полезна, если вы хотите получить доступ к свойству/ключу, но имя хранится в другой
переменной, как в этом примере:

```js
var obj = {
    a: "hello world",
    b: 42
};
var c = "a";
obj[c];			// "hello world"
obj["b"];		// 42
```

Есть пара других типов, с которыми предстоит взаимодействовать в JavaScript программах: *array* (массив) и *
function* (функция). Точнее, вместо того, чтобы быть полноценными встроенными типами, о них следует думать скорее как о
подтипах — особых версиях типа `object`.

#### Массивы

Массив — это `объект`, который хранит значения (любого типа) не в именованных свойствах/ключах, а в ячейках, доступных
по числовому индексу. Например:

```js
var arr = [
    "hello world",
    42,
    true
];
arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3
typeof arr;		// "object"
```

**Примечание:** Языки, которые начинают счет с нуля, как и JS, используют `0` в качестве индекса первого элемента
массива.

Полезно представить `arr` визуально:

<img src="fig5.png">

Поскольку массивы — это особые объекты (как намекает `typeof`), то у них могут быть свойства, включая автообновляемое
свойство `length` (длина).

Теоретически, вы можете использовать массив как обычный объект со своими собственными именованными свойствами или
использовать `object`, дав ему числовые свойства (`0`, `1` и т.д.) как у массива. Однако, в общем это было бы
использованием соответствующих типов не по назначению.

Лучшим и самым естественным подходом является использование массивов для значений, расположенных по числовым позициям, и
использовать `object` для именованных свойств.

#### Функции

Еще один подтип `object`, которым вы будете пользоваться во всех ваших JS программах — это функция:

```js
function foo() {
    return 42;
}

foo.bar = "hello world";
typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"

const foo = () => {
    return 42
}

() => {
    return 42
}
```

Еще раз, функции — это подтипы `объектов`: `typeof` вернет `"function"`, что говорит о том, что `function` является
основным типом, и поэтому у него могут быть свойства, но обычно вы в редких случаях будете пользоваться свойствами
функций (к примеру, `foo.bar`).

### Методы встроенных типов

Встроенные типы и подтипы, которые мы только что обсудили, содержат логику, отраженную в достаточно мощныx и полезныx
свойствах и методах.

Например:

```js
var a = "hello world";
var b = 3.14159;
a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"
```

Возможность вызова `a.toUpperCase()` более сложна и трудоемка, чем факт существования этого метода у значения.

Коротко говоря, есть форма обертки объекта `String` (заглавная `S`), обычно называемая "родной" (или "нативной"),
которая связывается с примитивным типом `string`; именно эта обертка определяет метод `toUpperCase()` в своем прототипе.

Когда вы используете примитивное значение, такое как `"hello world"`, подобно объекту, ссылаясь на свойство или метод (к
примеру, `a.toUpperCase()` в предыдущем кусочке кода), JS автоматически "упаковывает" значение в его обертку-двойника (
скрытую внутри).

Значение типа `string` может быть обернуто объектом `String`, значение типа `number` может быть обернуто
объектом `Number`, а `boolean` может быть обернуто объектом `Boolean`. В основном, вам не нужно беспокоиться о прямом
использовании этих оберток значений — отдавайте предпочтение примитивным формам значений практически во всех случаях, а
об остальном позаботится JavaScript.
